defmodule CodeIntelligenceTracer.FunctionExtractor do
  alias CodeIntelligenceTracer.AstNormalizer

  @moduledoc """
  Extracts function definitions with their locations from Elixir debug info.

  Parses the definitions list from debug info to extract function metadata
  including line numbers, kind (def/defp/defmacro/defmacrop), and source file.

  ## Function Record Structure

  Returns a map keyed by "function_name/arity:line" with values containing
  one entry per function clause:

      %{
        line: 10,
        kind: :def,
        guard: "is_binary(x)",
        pattern: "x",
        source_file: "lib/my_app/foo.ex",
        source_file_absolute: "/full/path/lib/my_app/foo.ex",
        source_sha: "a1b2c3...",
        ast_sha: "d4e5f6...",
        generated_by: nil,
        macro_source: nil,
        complexity: 1
      }

  Multi-clause functions produce multiple entries, one per clause.

  ## Macro-Generated Functions

  Functions generated by macros (e.g., `use GenServer`, `defstruct`) are detected
  via the `:context` metadata. For these functions:

  - `generated_by` contains the generating module name (e.g., "Phoenix.Endpoint")
  - `macro_source` contains the library source location (e.g., "deps/phoenix/lib/phoenix/endpoint.ex:552")
  - `end_line` equals `line` (body AST contains library line numbers, not user code)
  - `source_sha` is computed only for the invocation line

  ## Cyclomatic Complexity

  The `complexity` field contains the cyclomatic complexity of the function clause,
  computed by counting decision points in the body AST:

  - Base complexity: 1
  - `case` clauses: +1 per clause beyond the first
  - `cond` clauses: +1 per clause beyond the first
  - `if`/`unless`: +1
  - `with` match clauses: +1 per clause, +1 per else clause
  - `try`/`rescue`/`catch`: +1 per rescue/catch clause
  - `receive` clauses: +1 per clause beyond the first
  - `and`/`or`/`&&`/`||`: +1 (short-circuit evaluation)

  """

  @type function_kind :: :def | :defp | :defmacro | :defmacrop

  @type clause_info :: %{
          name: String.t(),
          arity: non_neg_integer(),
          line: non_neg_integer(),
          start_line: non_neg_integer(),
          end_line: non_neg_integer(),
          kind: function_kind(),
          guard: String.t() | nil,
          pattern: String.t(),
          source_file: String.t(),
          source_file_absolute: String.t(),
          source_sha: String.t() | nil,
          ast_sha: String.t(),
          generated_by: String.t() | nil,
          macro_source: String.t() | nil,
          complexity: non_neg_integer()
        }

  @doc """
  Extract function definitions with locations from debug info.

  Takes the definitions list from debug info and the source file path.
  Returns a map keyed by "function_name/arity:line" with one entry per clause.

  ## Parameters

    - `definitions` - List of function definitions from debug info
    - `source_file` - Absolute path to the source file

  ## Examples

      iex> extract_functions(definitions, "/path/to/lib/my_app/foo.ex")
      %{
        "process/2:10" => %{line: 10, kind: :def, guard: nil, pattern: "x, y", ...},
        "process/2:15" => %{line: 15, kind: :def, guard: "is_list(y)", pattern: "x, y", ...},
        "helper/1:27" => %{line: 27, kind: :defp, guard: nil, pattern: "_x", ...}
      }

  """
  @spec extract_functions(list(), String.t()) :: %{String.t() => clause_info()}
  def extract_functions(definitions, source_file_absolute) do
    source_file = make_relative_path(source_file_absolute)

    definitions
    |> Enum.flat_map(fn definition ->
      extract_clause_infos(definition, source_file, source_file_absolute)
    end)
    |> Map.new()
  end

  @doc """
  Resolve the source file path from debug info.

  Returns `{:ok, {relative_path, absolute_path}}` or `{:error, reason}`.

  The absolute path comes from the `:file` key in debug info.
  The relative path strips common prefixes to get "lib/..." or "test/...".

  ## Parameters

    - `debug_info` - Map from BeamReader.extract_debug_info/2
    - `beam_path` - Path to the BEAM file (used as fallback reference)

  """
  @spec resolve_source_path(map(), String.t()) ::
          {:ok, {String.t(), String.t()}} | {:error, String.t()}
  def resolve_source_path(debug_info, _beam_path) do
    case Map.get(debug_info, :file) do
      nil ->
        {:error, "No :file key in debug info"}

      file when is_binary(file) ->
        relative = make_relative_path(file)
        {:ok, {relative, file}}

      file when is_list(file) ->
        # Charlist path
        absolute = List.to_string(file)
        relative = make_relative_path(absolute)
        {:ok, {relative, absolute}}
    end
  end

  # Extract info for each clause in a function definition
  defp extract_clause_infos({{func_name, arity}, kind, def_meta, clauses}, source_file, source_file_absolute) do
    # Detect macro-generated functions via :context in definition metadata
    generated_by = Keyword.get(def_meta, :context)
    # Extract macro source location from :file tuple (present for generated functions)
    macro_file_info = Keyword.get(def_meta, :file)

    clauses
    |> Enum.map(fn {meta, args, guards, body} = clause ->
      line = Keyword.get(meta, :line, 0)

      # For macro-generated functions, don't compute end_line from body AST
      # because body line numbers often reference the library's source code
      end_line =
        if generated_by do
          line
        else
          max(line, find_max_line(body))
        end

      clause_key = "#{func_name}/#{arity}:#{line}"

      clause_info = %{
        name: to_string(func_name),
        arity: arity,
        line: line,
        start_line: line,
        end_line: end_line,
        kind: kind,
        guard: extract_guard(guards),
        pattern: args_to_string(args),
        source_file: source_file,
        source_file_absolute: source_file_absolute,
        source_sha: compute_source_sha(source_file_absolute, line, end_line),
        ast_sha: compute_clause_ast_sha(clause),
        generated_by: format_generated_by(generated_by),
        macro_source: format_macro_source(macro_file_info),
        complexity: compute_complexity(body)
      }

      {clause_key, clause_info}
    end)
  end

  # Format the generating module as a string, or nil if not generated
  defp format_generated_by(nil), do: nil

  defp format_generated_by(module) when is_atom(module) do
    module
    |> Atom.to_string()
    |> String.replace_leading("Elixir.", "")
  end

  # Format the macro source location as "relative/path.ex:line" or nil
  defp format_macro_source(nil), do: nil

  defp format_macro_source({path, line}) when is_binary(path) and is_integer(line) do
    relative_path = make_relative_path(path)
    "#{relative_path}:#{line}"
  end

  defp format_macro_source({path, line}) when is_list(path) and is_integer(line) do
    format_macro_source({List.to_string(path), line})
  end

  defp format_macro_source(_other), do: nil

  @doc """
  Compute cyclomatic complexity of a function body AST.

  Walks the AST and counts decision points to calculate complexity.
  Base complexity is 1, with additional points for branching constructs.

  ## Examples

      iex> compute_complexity({:ok, [], nil})
      1

      iex> compute_complexity({:if, [], [condition, [do: a, else: b]]})
      2

  """
  @spec compute_complexity(term()) :: non_neg_integer()
  def compute_complexity(body_ast) do
    {_ast, complexity} =
      Macro.prewalk(body_ast, 1, fn node, acc ->
        {node, acc + complexity_of(node)}
      end)

    complexity
  end

  # Calculate complexity contribution of a single AST node
  # case: +1 for each clause beyond the first
  defp complexity_of({:case, _meta, [_expr, [do: clauses]]}) when is_list(clauses) do
    max(0, length(clauses) - 1)
  end

  # cond: +1 for each clause beyond the first
  defp complexity_of({:cond, _meta, [[do: clauses]]}) when is_list(clauses) do
    max(0, length(clauses) - 1)
  end

  # if/unless: +1 for the branch
  defp complexity_of({op, _meta, _args}) when op in [:if, :unless] do
    1
  end

  # with: +1 for each <- clause, +1 for each else clause
  defp complexity_of({:with, _meta, args}) when is_list(args) do
    # Count <- clauses (match operations)
    match_clauses = Enum.count(args, fn
      {:<-, _, _} -> true
      _ -> false
    end)

    # Count else clauses if present
    else_clauses = case List.last(args) do
      [do: _, else: else_block] when is_list(else_block) -> length(else_block)
      [else: else_block] when is_list(else_block) -> length(else_block)
      _ -> 0
    end

    match_clauses + else_clauses
  end

  # try/rescue/catch: +1 for each rescue/catch clause
  defp complexity_of({:try, _meta, [block_opts]}) when is_list(block_opts) do
    rescue_count = case Keyword.get(block_opts, :rescue) do
      nil -> 0
      clauses when is_list(clauses) -> length(clauses)
      _ -> 0
    end

    catch_count = case Keyword.get(block_opts, :catch) do
      nil -> 0
      clauses when is_list(clauses) -> length(clauses)
      _ -> 0
    end

    rescue_count + catch_count
  end

  # receive: +1 for each clause beyond the first
  defp complexity_of({:receive, _meta, [[do: clauses]]}) when is_list(clauses) do
    max(0, length(clauses) - 1)
  end

  # receive with after: +1 for each clause beyond the first, +1 for after
  defp complexity_of({:receive, _meta, [[do: clauses, after: _after]]}) when is_list(clauses) do
    max(0, length(clauses) - 1) + 1
  end

  # Boolean operators (short-circuit): +1
  defp complexity_of({op, _meta, [_left, _right]}) when op in [:and, :or, :&&, :||] do
    1
  end

  # All other nodes: no complexity contribution
  defp complexity_of(_node), do: 0

  # Extract guard expression from a single clause as string
  defp extract_guard([]), do: nil
  defp extract_guard([single_guard]), do: guard_to_string(single_guard)
  defp extract_guard(multiple_guards), do: multiple_guards |> Enum.map(&guard_to_string/1) |> Enum.join(" and ")

  # Convert function arguments to human-readable string
  defp args_to_string([]), do: ""
  defp args_to_string(args) do
    args
    |> Enum.map(&arg_to_string/1)
    |> Enum.join(", ")
  end

  # Convert a single argument AST to string
  defp arg_to_string(arg) do
    arg
    |> AstNormalizer.strip_metadata()
    |> Macro.to_string()
  end

  # Convert a guard AST to a human-readable string
  # Guards in debug info use Erlang form like {:., [], [:erlang, :is_binary]}
  defp guard_to_string(guard_ast) do
    guard_ast
    |> AstNormalizer.normalize_guard_ast()
    |> Macro.to_string()
  end

  # Walk the AST to find the maximum line number
  defp find_max_line(ast) do
    {_ast, max_line} =
      Macro.prewalk(ast, 0, fn node, acc ->
        line = extract_line_from_node(node)
        {node, max(acc, line)}
      end)

    max_line
  end

  defp extract_line_from_node({_form, meta, _args}) when is_list(meta) do
    Keyword.get(meta, :line, 0)
  end

  defp extract_line_from_node(_), do: 0

  @doc """
  Compute SHA256 hash of source code for a function's line range.

  Reads the specified lines from the source file and computes a SHA256 hash.
  This hash changes when formatting, comments, or code changes.

  Returns `nil` if the source file doesn't exist or can't be read.

  ## Parameters

    - `source_file` - Absolute path to the source file
    - `start_line` - First line of the function (1-indexed)
    - `end_line` - Last line of the function (1-indexed)

  ## Examples

      iex> compute_source_sha("/path/to/lib/my_app/foo.ex", 10, 25)
      "a1b2c3d4..."

  """
  @spec compute_source_sha(String.t(), non_neg_integer(), non_neg_integer()) :: String.t() | nil
  def compute_source_sha(source_file, start_line, end_line) do
    # Ensure end_line is at least start_line (for single-line functions, body may have no line info)
    actual_end = max(start_line, end_line)

    case File.read(source_file) do
      {:ok, content} ->
        content
        |> String.split("\n")
        |> Enum.slice((start_line - 1)..(actual_end - 1)//1)
        |> Enum.join("\n")
        |> then(&:crypto.hash(:sha256, &1))
        |> Base.encode16(case: :lower)

      {:error, _} ->
        nil
    end
  end

  @doc """
  Compute SHA256 hash of normalized AST for function clauses.

  Normalizes the AST to remove non-semantic metadata (line numbers, etc.)
  and computes a SHA256 hash. This hash only changes when the actual
  logic changes, not formatting or comments.

  ## Parameters

    - `clauses` - List of function clauses from debug info

  ## Examples

      iex> compute_ast_sha(clauses)
      "e5f6g7h8..."

  """
  @spec compute_ast_sha(list()) :: String.t()
  def compute_ast_sha(clauses) do
    clauses
    |> normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Compute SHA256 hash of normalized AST for a single function clause.

  Same as `compute_ast_sha/1` but for a single clause tuple.

  ## Parameters

    - `clause` - A single function clause tuple: `{meta, args, guards, body}`

  """
  @spec compute_clause_ast_sha(tuple()) :: String.t()
  def compute_clause_ast_sha(clause) do
    clause
    |> normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Normalize AST by stripping non-semantic metadata.

  Removes `:line`, `:column`, `:counter`, `:file`, and other position
  metadata from the AST while preserving semantic structure.

  ## Parameters

    - `ast` - Any Elixir AST term

  ## Examples

      iex> normalize_ast({:foo, [line: 1, column: 5], [:arg]})
      {:foo, [], [:arg]}

  """
  @spec normalize_ast(term()) :: term()
  def normalize_ast(ast) when is_list(ast) do
    Enum.map(ast, &normalize_ast/1)
  end

  # Function clause tuple: {meta, args, guards, body}
  def normalize_ast({meta, args, guards, body}) when is_list(meta) do
    normalized_meta = strip_position_metadata(meta)
    {normalized_meta, normalize_ast(args), normalize_ast(guards), normalize_ast(body)}
  end

  # Standard AST node: {form, meta, args}
  def normalize_ast({form, meta, args}) when is_list(meta) do
    normalized_meta = strip_position_metadata(meta)
    normalized_args = normalize_ast(args)
    {form, normalized_meta, normalized_args}
  end

  def normalize_ast({left, right}) do
    {normalize_ast(left), normalize_ast(right)}
  end

  def normalize_ast(other), do: other

  # Strip position-related metadata keys
  defp strip_position_metadata(meta) do
    meta
    |> Keyword.drop([:line, :column, :counter, :file, :end_of_expression, :newlines, :closing, :do, :end])
  end

  # Convert absolute path to relative path
  # Strips everything up to and including "lib/" or "test/"
  defp make_relative_path(absolute_path) do
    cond do
      String.contains?(absolute_path, "/lib/") ->
        absolute_path
        |> String.split("/lib/", parts: 2)
        |> List.last()
        |> then(&("lib/" <> &1))

      String.contains?(absolute_path, "/test/") ->
        absolute_path
        |> String.split("/test/", parts: 2)
        |> List.last()
        |> then(&("test/" <> &1))

      true ->
        # Fallback: use basename
        Path.basename(absolute_path)
    end
  end
end
