defmodule CodeIntelligenceTracer.FunctionExtractor do
  @moduledoc """
  Extracts function definitions with their locations from Elixir debug info.

  Parses the definitions list from debug info to extract function metadata
  including line numbers, kind (def/defp/defmacro/defmacrop), and source file.

  ## Function Record Structure

  Returns a map keyed by "function_name/arity:line" with values containing
  one entry per function clause:

      %{
        line: 10,
        kind: :def,
        guard: "is_binary(x)",
        pattern: "x",
        source_file: "lib/my_app/foo.ex",
        source_file_absolute: "/full/path/lib/my_app/foo.ex",
        source_sha: "a1b2c3...",
        ast_sha: "d4e5f6...",
        generated_by: nil
      }

  Multi-clause functions produce multiple entries, one per clause.

  ## Macro-Generated Functions

  Functions generated by macros (e.g., `use GenServer`, `defstruct`) are detected
  via the `:context` metadata. For these functions:

  - `generated_by` contains the generating module name (e.g., "Phoenix.Endpoint")
  - `end_line` equals `line` (body AST contains library line numbers, not user code)
  - `source_sha` is computed only for the invocation line

  """

  @type function_kind :: :def | :defp | :defmacro | :defmacrop

  @type clause_info :: %{
          name: String.t(),
          arity: non_neg_integer(),
          line: non_neg_integer(),
          start_line: non_neg_integer(),
          end_line: non_neg_integer(),
          kind: function_kind(),
          guard: String.t() | nil,
          pattern: String.t(),
          source_file: String.t(),
          source_file_absolute: String.t(),
          source_sha: String.t() | nil,
          ast_sha: String.t(),
          generated_by: String.t() | nil
        }

  @doc """
  Extract function definitions with locations from debug info.

  Takes the definitions list from debug info and the source file path.
  Returns a map keyed by "function_name/arity:line" with one entry per clause.

  ## Parameters

    - `definitions` - List of function definitions from debug info
    - `source_file` - Absolute path to the source file

  ## Examples

      iex> extract_functions(definitions, "/path/to/lib/my_app/foo.ex")
      %{
        "process/2:10" => %{line: 10, kind: :def, guard: nil, pattern: "x, y", ...},
        "process/2:15" => %{line: 15, kind: :def, guard: "is_list(y)", pattern: "x, y", ...},
        "helper/1:27" => %{line: 27, kind: :defp, guard: nil, pattern: "_x", ...}
      }

  """
  @spec extract_functions(list(), String.t()) :: %{String.t() => clause_info()}
  def extract_functions(definitions, source_file_absolute) do
    source_file = make_relative_path(source_file_absolute)

    definitions
    |> Enum.flat_map(fn definition ->
      extract_clause_infos(definition, source_file, source_file_absolute)
    end)
    |> Map.new()
  end

  @doc """
  Resolve the source file path from debug info.

  Returns `{:ok, {relative_path, absolute_path}}` or `{:error, reason}`.

  The absolute path comes from the `:file` key in debug info.
  The relative path strips common prefixes to get "lib/..." or "test/...".

  ## Parameters

    - `debug_info` - Map from BeamReader.extract_debug_info/2
    - `beam_path` - Path to the BEAM file (used as fallback reference)

  """
  @spec resolve_source_path(map(), String.t()) ::
          {:ok, {String.t(), String.t()}} | {:error, String.t()}
  def resolve_source_path(debug_info, _beam_path) do
    case Map.get(debug_info, :file) do
      nil ->
        {:error, "No :file key in debug info"}

      file when is_binary(file) ->
        relative = make_relative_path(file)
        {:ok, {relative, file}}

      file when is_list(file) ->
        # Charlist path
        absolute = List.to_string(file)
        relative = make_relative_path(absolute)
        {:ok, {relative, absolute}}
    end
  end

  # Extract info for each clause in a function definition
  defp extract_clause_infos({{func_name, arity}, kind, def_meta, clauses}, source_file, source_file_absolute) do
    # Detect macro-generated functions via :context in definition metadata
    generated_by = Keyword.get(def_meta, :context)

    clauses
    |> Enum.map(fn {meta, args, guards, body} = clause ->
      line = Keyword.get(meta, :line, 0)

      # For macro-generated functions, don't compute end_line from body AST
      # because body line numbers often reference the library's source code
      end_line =
        if generated_by do
          line
        else
          max(line, find_max_line(body))
        end

      clause_key = "#{func_name}/#{arity}:#{line}"

      clause_info = %{
        name: to_string(func_name),
        arity: arity,
        line: line,
        start_line: line,
        end_line: end_line,
        kind: kind,
        guard: extract_guard(guards),
        pattern: args_to_string(args),
        source_file: source_file,
        source_file_absolute: source_file_absolute,
        source_sha: compute_source_sha(source_file_absolute, line, end_line),
        ast_sha: compute_clause_ast_sha(clause),
        generated_by: format_generated_by(generated_by)
      }

      {clause_key, clause_info}
    end)
  end

  # Format the generating module as a string, or nil if not generated
  defp format_generated_by(nil), do: nil

  defp format_generated_by(module) when is_atom(module) do
    module
    |> Atom.to_string()
    |> String.replace_leading("Elixir.", "")
  end

  # Extract guard expression from a single clause as string
  defp extract_guard([]), do: nil
  defp extract_guard([single_guard]), do: guard_to_string(single_guard)
  defp extract_guard(multiple_guards), do: multiple_guards |> Enum.map(&guard_to_string/1) |> Enum.join(" and ")

  # Convert function arguments to human-readable string
  defp args_to_string([]), do: ""
  defp args_to_string(args) do
    args
    |> Enum.map(&arg_to_string/1)
    |> Enum.join(", ")
  end

  # Convert a single argument AST to string
  defp arg_to_string(arg) do
    arg
    |> normalize_arg_ast()
    |> Macro.to_string()
  end

  # Normalize argument AST for readable output
  # Simplifies variable references and pattern matching
  defp normalize_arg_ast({:=, _meta, [left, right]}) do
    # Pattern match assignment: `{:ok, value} = result` -> show as `{:ok, value} = result`
    {:=, [], [normalize_arg_ast(left), normalize_arg_ast(right)]}
  end

  defp normalize_arg_ast({name, _meta, context}) when is_atom(name) and is_atom(context) do
    # Simple variable reference
    {name, [], context}
  end

  defp normalize_arg_ast({form, _meta, args}) when is_list(args) do
    {form, [], Enum.map(args, &normalize_arg_ast/1)}
  end

  defp normalize_arg_ast({left, right}) do
    {normalize_arg_ast(left), normalize_arg_ast(right)}
  end

  defp normalize_arg_ast(list) when is_list(list) do
    Enum.map(list, &normalize_arg_ast/1)
  end

  defp normalize_arg_ast(other), do: other

  # Convert a guard AST to a human-readable string
  # Guards in debug info use Erlang form like {:., [], [:erlang, :is_binary]}
  defp guard_to_string(guard_ast) do
    guard_ast
    |> normalize_guard_ast()
    |> Macro.to_string()
  end

  # Convert Erlang-style guard calls to Elixir-style for readable output
  # NOTE: Specific patterns for andalso/orelse must come before the general :erlang pattern
  defp normalize_guard_ast({{:., _meta, [:erlang, :andalso]}, call_meta, [left, right]}) do
    # Convert :erlang.andalso to `and`
    {:and, call_meta, [normalize_guard_ast(left), normalize_guard_ast(right)]}
  end

  defp normalize_guard_ast({{:., _meta, [:erlang, :orelse]}, call_meta, [left, right]}) do
    # Convert :erlang.orelse to `or`
    {:or, call_meta, [normalize_guard_ast(left), normalize_guard_ast(right)]}
  end

  defp normalize_guard_ast({{:., _meta, [:erlang, func]}, call_meta, args}) do
    # Convert :erlang.is_binary(x) to is_binary(x)
    normalized_args = Enum.map(args, &normalize_guard_ast/1)
    {func, call_meta, normalized_args}
  end

  defp normalize_guard_ast({form, meta, args}) when is_list(args) do
    {form, meta, Enum.map(args, &normalize_guard_ast/1)}
  end

  defp normalize_guard_ast({left, right}) do
    {normalize_guard_ast(left), normalize_guard_ast(right)}
  end

  defp normalize_guard_ast(list) when is_list(list) do
    Enum.map(list, &normalize_guard_ast/1)
  end

  defp normalize_guard_ast(other), do: other

  # Walk the AST to find the maximum line number
  defp find_max_line(ast) do
    {_ast, max_line} =
      Macro.prewalk(ast, 0, fn node, acc ->
        line = extract_line_from_node(node)
        {node, max(acc, line)}
      end)

    max_line
  end

  defp extract_line_from_node({_form, meta, _args}) when is_list(meta) do
    Keyword.get(meta, :line, 0)
  end

  defp extract_line_from_node(_), do: 0

  @doc """
  Compute SHA256 hash of source code for a function's line range.

  Reads the specified lines from the source file and computes a SHA256 hash.
  This hash changes when formatting, comments, or code changes.

  Returns `nil` if the source file doesn't exist or can't be read.

  ## Parameters

    - `source_file` - Absolute path to the source file
    - `start_line` - First line of the function (1-indexed)
    - `end_line` - Last line of the function (1-indexed)

  ## Examples

      iex> compute_source_sha("/path/to/lib/my_app/foo.ex", 10, 25)
      "a1b2c3d4..."

  """
  @spec compute_source_sha(String.t(), non_neg_integer(), non_neg_integer()) :: String.t() | nil
  def compute_source_sha(source_file, start_line, end_line) do
    # Ensure end_line is at least start_line (for single-line functions, body may have no line info)
    actual_end = max(start_line, end_line)

    case File.read(source_file) do
      {:ok, content} ->
        content
        |> String.split("\n")
        |> Enum.slice((start_line - 1)..(actual_end - 1)//1)
        |> Enum.join("\n")
        |> then(&:crypto.hash(:sha256, &1))
        |> Base.encode16(case: :lower)

      {:error, _} ->
        nil
    end
  end

  @doc """
  Compute SHA256 hash of normalized AST for function clauses.

  Normalizes the AST to remove non-semantic metadata (line numbers, etc.)
  and computes a SHA256 hash. This hash only changes when the actual
  logic changes, not formatting or comments.

  ## Parameters

    - `clauses` - List of function clauses from debug info

  ## Examples

      iex> compute_ast_sha(clauses)
      "e5f6g7h8..."

  """
  @spec compute_ast_sha(list()) :: String.t()
  def compute_ast_sha(clauses) do
    clauses
    |> normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Compute SHA256 hash of normalized AST for a single function clause.

  Same as `compute_ast_sha/1` but for a single clause tuple.

  ## Parameters

    - `clause` - A single function clause tuple: `{meta, args, guards, body}`

  """
  @spec compute_clause_ast_sha(tuple()) :: String.t()
  def compute_clause_ast_sha(clause) do
    clause
    |> normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Normalize AST by stripping non-semantic metadata.

  Removes `:line`, `:column`, `:counter`, `:file`, and other position
  metadata from the AST while preserving semantic structure.

  ## Parameters

    - `ast` - Any Elixir AST term

  ## Examples

      iex> normalize_ast({:foo, [line: 1, column: 5], [:arg]})
      {:foo, [], [:arg]}

  """
  @spec normalize_ast(term()) :: term()
  def normalize_ast(ast) when is_list(ast) do
    Enum.map(ast, &normalize_ast/1)
  end

  # Function clause tuple: {meta, args, guards, body}
  def normalize_ast({meta, args, guards, body}) when is_list(meta) do
    normalized_meta = strip_position_metadata(meta)
    {normalized_meta, normalize_ast(args), normalize_ast(guards), normalize_ast(body)}
  end

  # Standard AST node: {form, meta, args}
  def normalize_ast({form, meta, args}) when is_list(meta) do
    normalized_meta = strip_position_metadata(meta)
    normalized_args = normalize_ast(args)
    {form, normalized_meta, normalized_args}
  end

  def normalize_ast({left, right}) do
    {normalize_ast(left), normalize_ast(right)}
  end

  def normalize_ast(other), do: other

  # Strip position-related metadata keys
  defp strip_position_metadata(meta) do
    meta
    |> Keyword.drop([:line, :column, :counter, :file, :end_of_expression, :newlines, :closing, :do, :end])
  end

  # Convert absolute path to relative path
  # Strips everything up to and including "lib/" or "test/"
  defp make_relative_path(absolute_path) do
    cond do
      String.contains?(absolute_path, "/lib/") ->
        absolute_path
        |> String.split("/lib/", parts: 2)
        |> List.last()
        |> then(&("lib/" <> &1))

      String.contains?(absolute_path, "/test/") ->
        absolute_path
        |> String.split("/test/", parts: 2)
        |> List.last()
        |> then(&("test/" <> &1))

      true ->
        # Fallback: use basename
        Path.basename(absolute_path)
    end
  end
end
