defmodule ExAst.FunctionExtractor do
  alias ExAst.AstNormalizer
  alias ExAst.ComplexityAnalyzer
  alias ExAst.StringFormatting
  alias ExAst.Utils

  @moduledoc """
  Extracts function definitions with their locations from Elixir debug info.

  Parses the definitions list from debug info to extract function metadata
  including line numbers, kind (def/defp/defmacro/defmacrop), and source file.

  ## Function Record Structure

  Returns a map keyed by "function_name/arity:line" with values containing
  one entry per function clause:

      %{
        line: 10,
        kind: :def,
        guard: "is_binary(x)",
        pattern: "x",
        source_file: "lib/my_app/foo.ex",
        source_file_absolute: "/full/path/lib/my_app/foo.ex",
        source_sha: "a1b2c3...",
        ast_sha: "d4e5f6...",
        generated_by: nil,
        macro_source: nil,
        complexity: 1
      }

  Multi-clause functions produce multiple entries, one per clause.

  ## Macro-Generated Functions

  Functions generated by macros (e.g., `use GenServer`, `defstruct`) are detected
  via the `:context` metadata. For these functions:

  - `generated_by` contains the generating module name (e.g., "Phoenix.Endpoint")
  - `macro_source` contains the library source location (e.g., "deps/phoenix/lib/phoenix/endpoint.ex:552")
  - `end_line` equals `line` (body AST contains library line numbers, not user code)
  - `source_sha` is computed only for the invocation line

  ## Cyclomatic Complexity

  The `complexity` field contains the cyclomatic complexity of the function clause,
  computed by counting decision points in the body AST:

  - Base complexity: 1
  - `case` clauses: +1 per clause beyond the first
  - `cond` clauses: +1 per clause beyond the first
  - `if`/`unless`: +1
  - `with` match clauses: +1 per clause, +1 per else clause
  - `try`/`rescue`/`catch`: +1 per rescue/catch clause
  - `receive` clauses: +1 per clause beyond the first
  - `and`/`or`/`&&`/`||`: +1 (short-circuit evaluation)

  ## Data Format Conventions

  This module works with data structures following conventions documented in:
  - `docs/conventions/PARAMETER_FORMATTING.md` - Parameter naming and formatting
  - `docs/conventions/DATA_STRUCTURES.md` - Standard data structure definitions

  """

  @type function_kind :: :def | :defp | :defmacro | :defmacrop

  @type clause_info :: %{
          name: String.t(),
          arity: non_neg_integer(),
          line: non_neg_integer(),
          start_line: non_neg_integer(),
          end_line: non_neg_integer(),
          kind: function_kind(),
          guard: String.t() | nil,
          pattern: String.t(),
          source_file: String.t(),
          source_file_absolute: String.t(),
          source_sha: String.t() | nil,
          ast_sha: String.t(),
          generated_by: String.t() | nil,
          macro_source: String.t() | nil,
          complexity: non_neg_integer(),
          max_nesting_depth: non_neg_integer()
        }

  @doc """
  Extract function definitions with locations from debug info.

  Takes the definitions list from debug info and the source file path.
  Returns a map keyed by "function_name/arity:line" with one entry per clause.

  ## Parameters

    - `definitions` - List of function definitions from debug info
    - `source_file` - Absolute path to the source file

  ## Examples

      iex> extract_functions(definitions, "/path/to/lib/my_app/foo.ex")
      %{
        "process/2:10" => %{line: 10, kind: :def, guard: nil, pattern: "x, y", ...},
        "process/2:15" => %{line: 15, kind: :def, guard: "is_list(y)", pattern: "x, y", ...},
        "helper/1:27" => %{line: 27, kind: :defp, guard: nil, pattern: "_x", ...}
      }

  """
  @spec extract_functions(list(), String.t()) :: %{String.t() => clause_info()}
  def extract_functions(definitions, source_file_absolute) do
    source_file = make_relative_path(source_file_absolute)

    definitions
    |> Enum.flat_map(fn definition ->
      extract_clause_infos(definition, source_file, source_file_absolute)
    end)
    |> Map.new()
  end

  @doc """
  Resolve the source file path from debug info.

  Returns `{:ok, {relative_path, absolute_path}}` or `{:error, reason}`.

  The absolute path comes from the `:file` key in debug info.
  The relative path strips common prefixes to get "lib/..." or "test/...".

  ## Parameters

    - `debug_info` - Map from BeamReader.extract_debug_info/2
    - `beam_path` - Path to the BEAM file (used as fallback reference)

  """
  @spec resolve_source_path(map(), String.t()) ::
          {:ok, {String.t(), String.t()}} | {:error, String.t()}
  def resolve_source_path(debug_info, _beam_path) do
    case Map.get(debug_info, :file) do
      nil ->
        {:error, "No :file key in debug info"}

      file when is_binary(file) ->
        relative = make_relative_path(file)
        {:ok, {relative, file}}

      file when is_list(file) ->
        # Charlist path
        absolute = List.to_string(file)
        relative = make_relative_path(absolute)
        {:ok, {relative, absolute}}
    end
  end

  # Extract info for each clause in a function definition
  @spec extract_clause_infos(tuple(), String.t(), String.t()) :: [{String.t(), clause_info()}]
  defp extract_clause_infos({{func_name, arity}, kind, def_meta, clauses}, source_file, source_file_absolute) do
    # Detect macro-generated functions via :context in definition metadata
    generated_by = Keyword.get(def_meta, :context)
    # Extract macro source location from :file tuple (present for generated functions)
    macro_file_info = Keyword.get(def_meta, :file)

    clauses
    |> Enum.map(fn {meta, args, guards, body} = clause ->
      line = Keyword.get(meta, :line, 0)

      # For macro-generated functions, don't compute end_line from body AST
      # because body line numbers often reference the library's source code
      end_line =
        if generated_by do
          line
        else
          max(line, find_max_line(body))
        end

      clause_key = "#{func_name}/#{arity}:#{line}"

      clause_info = %{
        name: to_string(func_name),
        arity: arity,
        line: line,
        start_line: line,
        end_line: end_line,
        kind: kind,
        guard: extract_guard(guards),
        pattern: args_to_string(args),
        source_file: source_file,
        source_file_absolute: source_file_absolute,
        source_sha: compute_source_sha(source_file_absolute, line, end_line),
        ast_sha: compute_clause_ast_sha(clause),
        generated_by: format_generated_by(generated_by),
        macro_source: format_macro_source(macro_file_info),
        complexity: ComplexityAnalyzer.compute_complexity(body),
        max_nesting_depth: ComplexityAnalyzer.compute_max_nesting_depth(body)
      }

      {clause_key, clause_info}
    end)
  end

  # Format the generating module as a string, or nil if not generated
  @spec format_generated_by(atom() | nil) :: String.t() | nil
  defp format_generated_by(nil), do: nil

  defp format_generated_by(module) when is_atom(module) do
    Utils.module_to_string(module)
  end

  # Format the macro source location as "relative/path.ex:line" or nil
  @spec format_macro_source({String.t() | [integer()], non_neg_integer()} | nil) :: String.t() | nil
  defp format_macro_source(nil), do: nil

  defp format_macro_source({path, line}) when is_binary(path) and is_integer(line) do
    relative_path = make_relative_path(path)
    "#{relative_path}:#{line}"
  end

  defp format_macro_source({path, line}) when is_list(path) and is_integer(line) do
    format_macro_source({List.to_string(path), line})
  end

  defp format_macro_source(_other), do: nil

  # Extract guard expression from a single clause as string
  @spec extract_guard([term()]) :: String.t() | nil
  defp extract_guard([]), do: nil
  defp extract_guard(guards) do
    StringFormatting.join_with_separator(guards, " and ", &guard_to_string/1)
    |> case do
      "" -> nil
      result -> result
    end
  end

  # Convert function arguments to human-readable string
  @spec args_to_string([term()]) :: String.t()
  defp args_to_string(args) do
    StringFormatting.format_list(args, ", ", &arg_to_string/1, "")
  end

  # Convert a single argument AST to string
  @spec arg_to_string(term()) :: String.t()
  defp arg_to_string(arg) do
    arg
    |> AstNormalizer.strip_metadata()
    |> Macro.to_string()
  end

  # Convert a guard AST to a human-readable string
  # Guards in debug info use Erlang form like {:., [], [:erlang, :is_binary]}
  @spec guard_to_string(term()) :: String.t()
  defp guard_to_string(guard_ast) do
    guard_ast
    |> AstNormalizer.normalize_guard_ast()
    |> Macro.to_string()
  end

  # Walk the AST to find the maximum line number
  @spec find_max_line(term()) :: non_neg_integer()
  defp find_max_line(ast) do
    {_ast, max_line} =
      Macro.prewalk(ast, 0, fn node, acc ->
        line = AstNormalizer.extract_line_from_node(node)
        {node, max(acc, line)}
      end)

    max_line
  end

  @doc """
  Compute SHA256 hash of source code for a function's line range.

  Reads the specified lines from the source file and computes a SHA256 hash.
  This hash changes when formatting, comments, or code changes.

  Returns `nil` if the source file doesn't exist or can't be read.

  ## Parameters

    - `source_file` - Absolute path to the source file
    - `start_line` - First line of the function (1-indexed)
    - `end_line` - Last line of the function (1-indexed)

  ## Examples

      iex> compute_source_sha("/path/to/lib/my_app/foo.ex", 10, 25)
      "a1b2c3d4..."

  """
  @spec compute_source_sha(String.t(), non_neg_integer(), non_neg_integer()) :: String.t() | nil
  def compute_source_sha(source_file, start_line, end_line) do
    # Ensure end_line is at least start_line (for single-line functions, body may have no line info)
    actual_end = max(start_line, end_line)

    case File.read(source_file) do
      {:ok, content} ->
        content
        |> String.split("\n")
        |> Enum.slice((start_line - 1)..(actual_end - 1)//1)
        |> Enum.join("\n")
        |> then(&:crypto.hash(:sha256, &1))
        |> Base.encode16(case: :lower)

      {:error, _} ->
        nil
    end
  end

  @doc """
  Compute SHA256 hash of normalized AST for function clauses.

  Normalizes the AST to remove non-semantic metadata (line numbers, etc.)
  and computes a SHA256 hash. This hash only changes when the actual
  logic changes, not formatting or comments.

  ## Parameters

    - `clauses` - List of function clauses from debug info

  ## Examples

      iex> compute_ast_sha(clauses)
      "e5f6g7h8..."

  """
  @spec compute_ast_sha(list()) :: String.t()
  def compute_ast_sha(clauses) do
    clauses
    |> AstNormalizer.normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Compute SHA256 hash of normalized AST for a single function clause.

  Same as `compute_ast_sha/1` but for a single clause tuple.

  ## Parameters

    - `clause` - A single function clause tuple: `{meta, args, guards, body}`

  """
  @spec compute_clause_ast_sha(tuple()) :: String.t()
  def compute_clause_ast_sha(clause) do
    clause
    |> AstNormalizer.normalize_ast()
    |> :erlang.term_to_binary()
    |> then(&:crypto.hash(:sha256, &1))
    |> Base.encode16(case: :lower)
  end

  @doc """
  Normalize AST by stripping non-semantic metadata.

  Removes `:line`, `:column`, `:counter`, `:file`, and other position
  metadata from the AST while preserving semantic structure.

  This is a delegation to `AstNormalizer.normalize_ast/1` for backward compatibility.

  ## Parameters

    - `ast` - Any Elixir AST term

  ## Examples

      iex> normalize_ast({:foo, [line: 1, column: 5], [:arg]})
      {:foo, [], [:arg]}

  """
  @spec normalize_ast(term()) :: term()
  def normalize_ast(ast) do
    AstNormalizer.normalize_ast(ast)
  end

  # Convert absolute path to relative path
  # Strips everything up to and including "lib/" or "test/"
  @spec make_relative_path(String.t()) :: String.t()
  defp make_relative_path(absolute_path) do
    cond do
      String.contains?(absolute_path, "/lib/") ->
        absolute_path
        |> String.split("/lib/", parts: 2)
        |> List.last()
        |> then(&("lib/" <> &1))

      String.contains?(absolute_path, "/test/") ->
        absolute_path
        |> String.split("/test/", parts: 2)
        |> List.last()
        |> then(&("test/" <> &1))

      true ->
        # Fallback: use basename
        Path.basename(absolute_path)
    end
  end
end
