defmodule ExAst.FunctionExtractorIntegrationTest do
  use ExUnit.Case, async: true

  alias ExAst.BeamReader
  alias ExAst.FunctionExtractor

  # Helper to get BEAM file path for a module
  defp get_beam_path(module) do
    module_path = module |> Module.split() |> Enum.join(".")
    "_build/dev/lib/code_search_elixir_tracer/ebin/Elixir.#{module_path}.beam"
  end

  describe "extract_functions/2 with macro-generated functions" do
    test "detects macro-generated functions via context metadata" do
      # Stats module uses defstruct which generates __struct__/0 and __struct__/1
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # __struct__ functions are generated by defstruct (Kernel module)
      struct_entries = Enum.filter(functions, fn {key, _} -> String.starts_with?(key, "__struct__/") end)
      assert length(struct_entries) == 2

      for {_key, func_info} <- struct_entries do
        assert func_info.generated_by == "Kernel"
      end
    end

    test "macro-generated functions have end_line equal to line" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # Find generated functions
      generated = Enum.filter(functions, fn {_, info} -> info.generated_by != nil end)

      for {_key, func_info} <- generated do
        # For macro-generated functions, end_line should equal line (no body traversal)
        assert func_info.end_line == func_info.line,
          "Generated function should have end_line == line, got #{func_info.end_line} != #{func_info.line}"
      end
    end

    test "regular functions have nil generated_by" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # Find regular (non-generated) functions
      regular = Enum.filter(functions, fn {_, info} -> info.generated_by == nil end)

      assert length(regular) > 0, "Should have regular functions"

      for {_key, func_info} <- regular do
        assert func_info.generated_by == nil
      end
    end

    test "regular functions can have end_line > line" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # Find record_success/6 which has a multi-line body
      {_key, func_info} = Enum.find(functions, fn {key, _} -> String.starts_with?(key, "record_success/6:") end)

      # Regular functions should have proper line spans computed from body
      assert func_info.end_line > func_info.line,
        "Regular multi-line function should have end_line > line"
      assert func_info.generated_by == nil
    end

    test "all functions include generated_by field" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.BeamReader))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      for {_key, func_info} <- functions do
        assert Map.has_key?(func_info, :generated_by),
          "Function info should have :generated_by key"
      end
    end

    test "all functions include macro_source field" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.BeamReader))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      for {_key, func_info} <- functions do
        assert Map.has_key?(func_info, :macro_source),
          "Function info should have :macro_source key"
      end
    end

    test "regular functions have nil macro_source" do
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # Find regular (non-generated) functions
      regular = Enum.filter(functions, fn {_, info} -> info.generated_by == nil end)

      for {_key, func_info} <- regular do
        assert func_info.macro_source == nil,
          "Regular function should have nil macro_source"
      end
    end

    test "macro_source format is path:line when present" do
      # We need a BEAM file from a Phoenix app to test this
      # For now, test that the format helper works correctly by checking
      # that any macro_source values match the expected pattern
      {:ok, {module, chunks}} = BeamReader.read_chunks(get_beam_path(ExAst.Extractor.Stats))
      {:ok, debug_info} = BeamReader.extract_debug_info(chunks, module)

      functions = FunctionExtractor.extract_functions(debug_info.definitions, debug_info.file)

      # Find functions with macro_source
      with_source = Enum.filter(functions, fn {_, info} -> info.macro_source != nil end)

      for {_key, func_info} <- with_source do
        # Should be in format "path/file.ex:123"
        assert func_info.macro_source =~ ~r/.+:\d+$/,
          "macro_source should be in format 'path:line', got: #{func_info.macro_source}"
      end
    end
  end
end
