# Parameter Formatting Conventions

This document establishes standard conventions for parameter names and formatting across the codebase.

## Overview

Consistent parameter naming and formatting improves:
- Code readability and discoverability
- Onboarding for new contributors
- IDE autocomplete and inspection
- Consistency across modules

## Function Names

All function names should be stored as atoms:
- `:process_data`, `:handle_call`, `:__init__`
- NOT: `"process_data"`, `"handle_call"`

When extracting from AST or debug info, convert atoms directly without modification.

## Function Arity

Always store function arity as an integer:
- `1`, `2`, `3`, etc.
- Never: `"1"`, strings or other types

The arity represents the number of parameters the function accepts.

## Source Files

Source file paths should be stored in two consistent forms:

### Relative Path (`source_file`)
- Format: `lib/my_app/foo.ex`, `test/my_app/foo_test.exs`
- Always relative to project root
- Always use forward slashes (`/`), even on Windows
- Store as string
- Used for display in output and logs

### Absolute Path (`source_file_absolute`)
- Format: `/home/user/project/lib/my_app/foo.ex`
- Complete filesystem path from root
- Store as string
- Used internally for reading file contents (e.g., computing source SHA)

## Example Paths

```elixir
%{
  source_file: "lib/my_app/foo.ex",                    # relative
  source_file_absolute: "/home/user/project/lib/my_app/foo.ex",  # absolute
}
```

## Line Numbers

All line numbers should be integers using 1-indexing:
- First line of file: `1`
- Second line of file: `2`
- NOT 0-indexed

### Line Number Fields

| Field | Purpose | Example |
|-------|---------|---------|
| `line` | Primary line number (where entity is defined) | `10` |
| `start_line` | First line of function body | `10` |
| `end_line` | Last line of function body | `25` |

## Classification Atoms

Use consistent atoms for classification across modules:

### Function Kind
- `:def` - Public function
- `:defp` - Private function
- `:defmacro` - Public macro
- `:defmacrop` - Private macro
- `:defdelegate` - Delegated function

### Spec/Type Kind
- `:spec` - Type specification
- `:callback` - Behavior callback
- `:type` - Type definition
- `:opaque` - Opaque type

### Call Type
- `:remote` - Remote call (`Module.function(args)`)
- `:local` - Local call (`function(args)`)
- `:capture` - Function capture (`&Module.function/arity`)

## Metadata Fields

### Generated Functions

For functions generated by macros (e.g., via `use GenServer`, `defstruct`):

| Field | Type | Purpose |
|-------|------|---------|
| `generated_by` | `String.t() \| nil` | Module that generated the function, e.g., `"Kernel"`, `"Phoenix.Endpoint"` |
| `macro_source` | `String.t() \| nil` | Location where macro was invoked, format: `"path/file.ex:123"` |

**Examples:**
```elixir
# Function generated by defstruct
%{
  generated_by: "Kernel",
  macro_source: "lib/my_app/user.ex:10"
}

# Regular user-defined function
%{
  generated_by: nil,
  macro_source: nil
}
```

## Hashes

### Source SHA (`source_sha`)
- SHA256 hash of source code lines
- Changes on any formatting, comment, or code change
- Calculated from `start_line` to `end_line` of source file
- Type: `String.t() | nil` (nil if source file unavailable)
- Hex-encoded lowercase: `"a1b2c3d4e5f6..."`

### AST SHA (`ast_sha`)
- SHA256 hash of normalized AST
- Changes only on semantic changes (ignores formatting/comments)
- Calculated on normalized (metadata-stripped) AST
- Type: `String.t()`
- Hex-encoded lowercase: `"f6e5d4c3b2a1..."`

## Argument Formatting

When capturing call arguments as strings:
- Variable: `"x"`, `"list"`
- Literal string: `"\"hello\""`  (with quotes)
- Literal integer: `"42"`
- Tuple pattern: `"{:ok, value}"`
- Multiple args: `"x, y, z"` (comma-separated)
- Zero-arity calls: empty string `""`

## Parameter Ordering Conventions

### Extract Functions
Parameters should follow this order:
```
extract_functions(definitions, source_file)
extract_specs(chunks)
extract_calls(body, module)
extract_types(chunks)
```

Pattern:
1. Primary input (AST/chunks)
2. Context (module, source_file)

### Format Functions
Parameters should follow this order:
```
format_spec(spec)
format_clause(clause, name, kind)
format_type_string(type_ast)
```

Pattern:
1. Data to format
2. Contextual parameters (name, kind)

### Compute Functions
Parameters should follow this order:
```
compute_complexity(ast)
compute_max_nesting_depth(ast)
compute_source_sha(source_file, start_line, end_line)
```

Pattern:
1. Data to analyze
2. Optional parameters for computation control

## Summary Table

| Aspect | Format | Type | Example |
|--------|--------|------|---------|
| **Function name** | atom | `atom()` | `:process_data` |
| **Function arity** | integer | `non_neg_integer()` | `2` |
| **Relative file path** | forward slashes | `String.t()` | `"lib/foo.ex"` |
| **Absolute file path** | forward slashes | `String.t()` | `"/home/user/lib/foo.ex"` |
| **Line number** | integer (1-indexed) | `non_neg_integer()` | `10` |
| **Function kind** | atom | `atom()` | `:def` |
| **Spec kind** | atom | `atom()` | `:spec` |
| **Call type** | atom | `atom()` | `:remote` |
| **Generated by** | module string or nil | `String.t() \| nil` | `"Kernel"` |
| **Macro source** | path:line or nil | `String.t() \| nil` | `"lib/foo.ex:10"` |
| **Source SHA** | hex lowercase | `String.t() \| nil` | `"a1b2c3..."` |
| **AST SHA** | hex lowercase | `String.t()` | `"f6e5d4..."` |
